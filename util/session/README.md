<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# session

## Introduction
Session is used to initialtively or automatically manage and transmit context between goroutines.

## Index

- [Constants](<#constants>)
- [func BindSession(s Session)](<#func-bindsession>)
- [func Go(f func())](<#func-go>)
- [func GoSession(s Session, f func())](<#func-gosession>)
- [func SetDefaultManager(m SessionManager)](<#func-setdefaultmanager>)
- [func UnbindSession()](<#func-unbindsession>)
- [type ManagerOptions](<#type-manageroptions>)
- [type Session](<#type-session>)
  - [func CurSession() (Session, bool)](<#func-cursession>)
- [type SessionCtx](<#type-sessionctx>)
  - [func NewSessionCtx(ctx context.Context) *SessionCtx](<#func-newsessionctx>)
  - [func NewSessionCtxWithTimeout(ctx context.Context, timeout time.Duration) *SessionCtx](<#func-newsessionctxwithtimeout>)
  - [func (self SessionCtx) Disable()](<#func-sessionctx-disable>)
  - [func (self *SessionCtx) Get(key interface{}) interface{}](<#func-sessionctx-get>)
  - [func (self *SessionCtx) IsValid() bool](<#func-sessionctx-isvalid>)
  - [func (self SessionCtx) WithValue(key interface{}, val interface{}) Session](<#func-sessionctx-withvalue>)
- [type SessionID](<#type-sessionid>)
- [type SessionManager](<#type-sessionmanager>)
  - [func GetDefaultManager() SessionManager](<#func-getdefaultmanager>)
  - [func NewSessionManager(opts ManagerOptions) SessionManager](<#func-newsessionmanager>)
  - [func (self SessionManager) BindSession(id SessionID, s Session)](<#func-sessionmanager-bindsession>)
  - [func (self SessionManager) GC()](<#func-sessionmanager-gc>)
  - [func (self SessionManager) GetSession(id SessionID) (Session, bool)](<#func-sessionmanager-getsession>)
  - [func (self SessionManager) Options() ManagerOptions](<#func-sessionmanager-options>)
  - [func (self SessionManager) UnbindSession(id SessionID)](<#func-sessionmanager-unbindsession>)
- [type SessionMap](<#type-sessionmap>)
  - [func NewSessionMap(m map[interface{}]interface{}) *SessionMap](<#func-newsessionmap>)
  - [func NewSessionMapWithTimeout(m map[interface{}]interface{}, timeout time.Duration) *SessionMap](<#func-newsessionmapwithtimeout>)
  - [func (self *SessionMap) Disable()](<#func-sessionmap-disable>)
  - [func (self *SessionMap) Get(key interface{}) interface{}](<#func-sessionmap-get>)
  - [func (self *SessionMap) IsValid() bool](<#func-sessionmap-isvalid>)
  - [func (self *SessionMap) WithValue(key interface{}, val interface{}) Session](<#func-sessionmap-withvalue>)


## Constants

```go
const (
    // DefaultShardNum set the sharding number of id->sesssion map for default SessionManager
    DefaultShardNum = 100

    // DefaultGCInterval set the GC interval for default SessionManager
    DefaultGCInterval = time.Hour

    // DefaultEnableTransparentTransmitAsync enables TransparentTransmitAsync for default SessionManager
    DefaultEnableTransparentTransmitAsync = false
)
```

```go
const Pprof_Label_Session_ID = "go_session_id"
```

## func [BindSession](<https://github.com/bytedance/gopkg/blob/develop/util/session/gls.go#L66>)

```go
func BindSession(s Session)
```

BindSession binds the session with current goroutine

## func [Go](<https://github.com/bytedance/gopkg/blob/develop/util/session/gls.go#L80>)

```go
func Go(f func())
```

Go calls f asynchronously and pass caller's session to the new goroutine

## func [GoSession](<https://github.com/bytedance/gopkg/blob/develop/util/session/gls.go#L90>)

```go
func GoSession(s Session, f func())
```

SessionGo calls f asynchronously and pass s session to the new goroutine

## func [SetDefaultManager](<https://github.com/bytedance/gopkg/blob/develop/util/session/gls.go#L49>)

```go
func SetDefaultManager(m SessionManager)
```

SetDefaultManager updates default SessionManager to m

## func [UnbindSession](<https://github.com/bytedance/gopkg/blob/develop/util/session/gls.go#L75>)

```go
func UnbindSession()
```

### UnbindSession unbind a session \(if any\) with current goroutine

Notice: If you want to end the session, please call \`Disable\(\)\` \(or whatever make the session invalid\) on your session's implementation

## type [ManagerOptions](<https://github.com/bytedance/gopkg/blob/develop/util/session/manager.go#L26-L35>)

ManagerOptions for SessionManager

```go
type ManagerOptions struct {
    // EnableTransparentTransmitAsync enables transparently transmit
    // current session to children goroutines
    EnableTransparentTransmitAsync bool
    // ShardNumber is used to shard session id, it must be larger than zero
    ShardNumber int
    // GCInterval decides the GC interval for SessionManager,
    // it must be larger than 1s or zero means disable GC
    GCInterval time.Duration
}
```

## type [Session](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L27-L36>)

Session represents a local storage for one session

```go
type Session interface {
    // IsValid tells if the session is valid at present
    IsValid() bool

    // Get returns value for specific key
    Get(key interface{}) interface{}

    // WithValue sets value for specific key，and return newly effective session
    WithValue(key interface{}, val interface{}) Session
}
```

### func [CurSession](<https://github.com/bytedance/gopkg/blob/develop/util/session/gls.go#L60>)

```go
func CurSession() (Session, bool)
```

CurSession gets the session for current goroutine

## type [SessionCtx](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L40-L43>)

SessionCtx implements Session with context, which means children session WON'T affect parent and sibling sessions

```go
type SessionCtx struct {
    // contains filtered or unexported fields
}
```

<details><summary>Example</summary>
<p>

```go
/**
 * Copyright 2023 ByteDance Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

import (
	"context"
)

func ASSERT(v bool) {
	if !v {
		panic("not true!")
	}
}

func GetCurSession() Session {
	s, ok := CurSession()
	if !ok {
		panic("can't get current seession!")
	}
	return s
}

func main() {
	var ctx = context.Background()
	var key, v = "a", "b"
	var key2, v2 = "c", "d"
	var sig = make(chan struct{})
	var sig2 = make(chan struct{})

	// initialize new session with context
	var session = NewSessionCtx(ctx) // implementation...

	// set specific key-value and update session
	start := session.WithValue(key, v)

	// set current session
	BindSession(start)

	// pass to new goroutine...
	Go(func() {
		// read specific key under current session
		val := GetCurSession().Get(key) // val exists
		ASSERT(val == v)
		// doSomething....

		// set specific key-value under current session
		// NOTICE: current session won't change here
		next := GetCurSession().WithValue(key2, v2)
		val2 := GetCurSession().Get(key2) // val2 == nil
		ASSERT(val2 == nil)

		// pass both parent session and new session to sub goroutine
		GoSession(next, func() {
			// read specific key under current session
			val := GetCurSession().Get(key) // val exists
			ASSERT(val == v)

			val2 := GetCurSession().Get(key2) // val2 exists
			ASSERT(val2 == v2)
			// doSomething....

			sig2 <- struct{}{}

			<-sig
			ASSERT(GetCurSession().IsValid() == false) // current session is invalid

			println("g2 done")
			sig2 <- struct{}{}
		})

		Go(func() {
			// read specific key under current session
			val := GetCurSession().Get(key) // val exists
			ASSERT(v == val)

			val2 := GetCurSession().Get(key2) // val2 == nil
			ASSERT(val2 == nil)
			// doSomething....

			sig2 <- struct{}{}

			<-sig
			ASSERT(GetCurSession().IsValid() == false) // current session is invalid

			println("g3 done")
			sig2 <- struct{}{}
		})

		BindSession(next)
		val2 = GetCurSession().Get(key2) // val2 exists
		ASSERT(v2 == val2)

		sig2 <- struct{}{}

		<-sig
		ASSERT(next.IsValid() == false) // next is invalid

		println("g1 done")
		sig2 <- struct{}{}
	})

	<-sig2
	<-sig2
	<-sig2

	val2 := GetCurSession().Get(key2) // val2 == nil
	ASSERT(val2 == nil)

	// initiatively ends the session，
	// then all the inherited session (including next) will be disabled
	session.Disable()
	close(sig)

	ASSERT(start.IsValid() == false) // start is invalid

	<-sig2
	<-sig2
	<-sig2
	println("g0 done")

	UnbindSession()
}
```

</p>
</details>

### func [NewSessionCtx](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L46>)

```go
func NewSessionCtx(ctx context.Context) *SessionCtx
```

NewSessionCtx creates and enables a SessionCtx

### func [NewSessionCtxWithTimeout](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L57>)

```go
func NewSessionCtxWithTimeout(ctx context.Context, timeout time.Duration) *SessionCtx
```

NewSessionCtx creates and enables a SessionCtx, and disable the session after timeout

### func \(SessionCtx\) [Disable](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L67>)

```go
func (self SessionCtx) Disable()
```

Disable ends the session

### func \(\*SessionCtx\) [Get](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L80>)

```go
func (self *SessionCtx) Get(key interface{}) interface{}
```

Get value for specific key

### func \(\*SessionCtx\) [IsValid](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L72>)

```go
func (self *SessionCtx) IsValid() bool
```

IsValid tells if the session is valid at present

### func \(SessionCtx\) [WithValue](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L88>)

```go
func (self SessionCtx) WithValue(key interface{}, val interface{}) Session
```

Set value for specific key，and return newly effective session

## type [SessionID](<https://github.com/bytedance/gopkg/blob/develop/util/session/manager.go#L87>)

SessionID is the indentity of a session

```go
type SessionID uint64
```

## type [SessionManager](<https://github.com/bytedance/gopkg/blob/develop/util/session/manager.go#L45-L49>)

SessionManager maintain and manage sessions

```go
type SessionManager struct {
    // contains filtered or unexported fields
}
```

### func [GetDefaultManager](<https://github.com/bytedance/gopkg/blob/develop/util/session/gls.go#L55>)

```go
func GetDefaultManager() SessionManager
```

GetDefaultManager returns a copy of default SessionManager warning: use it only for state check

### func [NewSessionManager](<https://github.com/bytedance/gopkg/blob/develop/util/session/manager.go#L62>)

```go
func NewSessionManager(opts ManagerOptions) SessionManager
```

NewSessionManager creates a SessionManager with default containers If opts.GCInterval \> 0, it will start scheduled GC\(\) loop automatically

### func \(SessionManager\) [BindSession](<https://github.com/bytedance/gopkg/blob/develop/util/session/manager.go#L129>)

```go
func (self SessionManager) BindSession(id SessionID, s Session)
```

BindSession binds the session with current goroutine

### func \(SessionManager\) [GC](<https://github.com/bytedance/gopkg/blob/develop/util/session/manager.go#L158>)

```go
func (self SessionManager) GC()
```

GC sweep invalid sessions and release unused memory

### func \(SessionManager\) [GetSession](<https://github.com/bytedance/gopkg/blob/develop/util/session/manager.go#L110>)

```go
func (self SessionManager) GetSession(id SessionID) (Session, bool)
```

Get gets specific session or get inherited session if option EnableTransparentTransmitAsync is true

### func \(SessionManager\) [Options](<https://github.com/bytedance/gopkg/blob/develop/util/session/manager.go#L82>)

```go
func (self SessionManager) Options() ManagerOptions
```

Options shows the manager's Options

### func \(SessionManager\) [UnbindSession](<https://github.com/bytedance/gopkg/blob/develop/util/session/manager.go#L144>)

```go
func (self SessionManager) UnbindSession(id SessionID)
```

#### UnbindSession clears current session

Notice: If you want to end the session, please call \`Disable\(\)\` \(or whatever make the session invalid\) on your session's implementation

## type [SessionMap](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L98-L102>)

NewSessionMap implements Session with map, which means children session WILL affect parent session and sibling sessions

```go
type SessionMap struct {
    // contains filtered or unexported fields
}
```

### func [NewSessionMap](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L105>)

```go
func NewSessionMap(m map[interface{}]interface{}) *SessionMap
```

NewSessionMap creates and enables a SessionMap

### func [NewSessionMapWithTimeout](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L116>)

```go
func NewSessionMapWithTimeout(m map[interface{}]interface{}, timeout time.Duration) *SessionMap
```

NewSessionCtx creates and enables a SessionCtx, and disable the session after timeout

### func \(\*SessionMap\) [Disable](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L134>)

```go
func (self *SessionMap) Disable()
```

Disable ends the session

### func \(\*SessionMap\) [Get](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L139>)

```go
func (self *SessionMap) Get(key interface{}) interface{}
```

Get value for specific key

### func \(\*SessionMap\) [IsValid](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L126>)

```go
func (self *SessionMap) IsValid() bool
```

IsValid tells if the session is valid at present

### func \(\*SessionMap\) [WithValue](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L150>)

```go
func (self *SessionMap) WithValue(key interface{}, val interface{}) Session
```

Set value for specific key，and return itself



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
